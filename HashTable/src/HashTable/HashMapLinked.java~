package HashTable;

/**
 * 
 * Хэш-таблица - структура данных, реализующая интерфейс ассоциативного массива(ассоциативный массив - массив, индексами 
 * которого могут являться не только целые числа от 0 или 1, но и объекты любой другой природы), она позволяет хранить пары
 * ключ-значение и выполнять операции добавления ключа и значения, поиска по ключу и удаления по ключу.
 * 
 * Достоинства хэш-таблиц:
 * 1. Очень быстрый доступ к элементу если известен ключ.
 * 2. Возможность работы с неупорядоченными ключами.
 * 3. Сравнительно быстрое удаление и вставка.
 * 
 * Недостатки хэш-таблиц:
 * 1. Итерация не в порядке возрастания ключей.
 * 2. Медленное удаление и доступ к элементу если неизвестен ключ.
 * 3. Неэффективное использование памяти.
 * 4. Необходимость "перехеширования" при увеличении количества хранимых объектов.
 * 
 * Практическое применение хэш-таблиц:
 * 1. Базы данных телефонных номеров.
 * 2. Каталоги книг.
 * 3. Поиск информации о водителе по номеру его водительского удостоверения.
 * 4. Браузер хранит адреса посещенных страниц в хэш-таблице.
 * 
 * Ситуация, когда для двух различных ключей получается одно и то же значение хэш-функции называется коллизией. 
 * Коллизии существуют для большинства хеш-функций, но для «хороших» хеш-функций частота их возникновения близка к 
 * теоретическому минимуму. В некоторых специальных случаях удаётся избежать коллизий вообще. Например, если все ключи 
 * элементов известны заранее (или очень редко меняются), то для них можно найти некоторую совершенную хеш-функцию, которая 
 * распределит их по ячейкам хеш-таблицы без коллизий. Хеш-таблицы, использующие подобные хеш-функции, не нуждаются в 
 * механизме разрешения коллизий, и называются хеш-таблицами с прямой адресацией.
 * Число хранимых элементов деленное на размер массива называется коэффициентом заполнения хэш-таблицы. От этого параметра
 * зависит время выполнения операций.
 * 
 * Важное свойство хеш-таблиц состоит в том, что, при некоторых разумных допущениях, все три операции (поиск, вставка, 
 * удаление элементов) в среднем выполняются за время O(1). Но при этом не гарантируется, что время выполнения отдельной 
 * операции мало́. Это связано с тем, что при достижении некоторого значения коэффициента заполнения необходимо осуществлять 
 * перестройку индекса хеш-таблицы: увеличить значение размера массива H и заново добавить в пустую хеш-таблицу все пары.
 * 
 * Существуют несколько способов разрешения от коллизий. 1 метод - метод цепочек, 2 метод - открытой адресацией.
 * 
 * Метод цепочек:
 * Каждая ячейка массива H является указателем на связный список (цепочку) пар ключ-значение, соответствующих одному и тому 
 * же хеш-значению ключа. Коллизии просто приводят к тому, что появляются цепочки длиной более одного элемента.
 * Операции поиска или удаления элемента требуют просмотра всех элементов соответствующей ему цепочки, чтобы найти в ней 
 * элемент с заданным ключом. Для добавления элемента нужно добавить элемент в конец или начало соответствующего списка, и, 
 * в случае, если коэффициент заполнения станет слишком велик, увеличить размер массива H и перестроить таблицу.
 * При предположении, что каждый элемент может попасть в любую позицию таблицы H с равной вероятностью и независимо от того, 
 * куда попал любой другой элемент, среднее время работы операции поиска элемента составляет Θ(1 + α), где α — коэффициент 
 * заполнения таблицы.
 *
 *
 *	В этом случае каждый i-ый элемент массива t хранит список(цепочку) пар в виде (Kj,Vj), такие что h(Kj) = i.При операции put 
 *	сначала будет проверяться в списке наличие ключа Kj. Если такой ключ существует, обновляем значение Vj. В противном случае 
 *	добавляем в этот список пару (Kj,Vj). При операции get и del также будет проверятся наличие ключа Kj и в случае успеха будет 
 *	возвращаться(удаляться) значение Vj для get(del).
 *
 */

public class HashMapLinked {

	public class LinkedHashEntry {
		
		private int key;
		private String value;
		LinkedHashEntry next;
		
		public LinkedHashEntry(int key, String value) {
			
			this.key = key;
			this.value = value;
			this.next = null;
		}
		
		public int getKey() {
			
			return key;
		}
		
		public void setValue(String value) {
			
			this.value = value;
		}
		
		public String getValue() {
			
			return value;
		}
		
		public void setNext(LinkedHashEntry next) {
			
			this.next = next;
		}
		
		public LinkedHashEntry getNext() {
			
			return next;
		}
	}
	
	private static final int TABLE_SIZE = 128;
	LinkedHashEntry[] table;
	
	public HashMapLinked() {
		
		table = new LinkedHashEntry[TABLE_SIZE];
		
		for(int i = 0; i < table.length; i ++) {
			
			table[i] = null;
		}
	}
	
	public void add(int key, String value) {
		
		int hash = key % TABLE_SIZE;
		
		if(table[hash] == null) {
			
			table[hash] = new LinkedHashEntry(key, value);
		}	else {
			
			LinkedHashEntry entry = table[hash];
			
			while(entry.getNext() != null && entry.getKey() != key) 
				
				entry = entry.getNext();
			
			if(entry.getKey() == key) {
				
				entry.setValue(value);
			}	else {
				
				entry.setNext(new LinkedHashEntry(key, value));
			}
		}
	}
	
	public String get(int key) {
		
		int hash = key % TABLE_SIZE;
		
		if(table[hash] == null) {
			
			return "";
		}	else {
			
			LinkedHashEntry entry = table[hash];
			
			while(entry != null && entry.getKey() != key) 
				
				entry = entry.getNext();
			
			if(entry == null) {
				
				return "";
			}	else {
				
				return entry.getValue();
			}
		}
	}
	
	public void remove(int key) {
		
		int hash = key % TABLE_SIZE;
		
		if(table[hash] != null) {
			
			LinkedHashEntry prevEntry = null;
			LinkedHashEntry entry = table[hash];
			
			while(entry.getNext() != null && entry.getKey() != key) {
				
				prevEntry = entry;
				entry = entry.getNext();
			}
			
			if(prevEntry == null) {
				
				table[hash] = entry.getNext();
			}	else {
				
				prevEntry.setNext(entry.getNext());
			}
		}
	}
}
