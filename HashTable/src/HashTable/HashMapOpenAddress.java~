package HashTable;


/**
 * 
 * Хэш-таблица - структура данных, реализующая интерфейс ассоциативного массива(ассоциативный массив - массив, индексами 
 * которого могут являться не только целые числа от 0 или 1, но и объекты любой другой природы), она позволяет хранить пары
 * ключ-значение и выполнять операции добавления ключа и значения, поиска по ключу и удаления по ключу.
 * 
 * Достоинства хэш-таблиц:
 * 1. Очень быстрый доступ к элементу если известен ключ.
 * 2. Возможность работы с неупорядоченными ключами.
 * 3. Сравнительно быстрое удаление и вставка.
 * 
 * Недостатки хэш-таблиц:
 * 1. Итерация не в порядке возрастания ключей.
 * 2. Медленное удаление и доступ к элементу если неизвестен ключ.
 * 3. Неэффективное использование памяти.
 * 4. Необходимость "перехеширования" при увеличении количества хранимых объектов.
 * 
 * Практическое применение хэш-таблиц:
 * 1. Базы данных телефонных номеров.
 * 2. Каталоги книг.
 * 3. Поиск информации о водителе по номеру его водительского удостоверения.
 * 4. Браузер хранит адреса посещенных страниц в хэш-таблице.
 * 
 * Ситуация, когда для двух различных ключей получается одно и то же значение хэш-функции называется коллизией. 
 * Коллизии существуют для большинства хеш-функций, но для «хороших» хеш-функций частота их возникновения близка к 
 * теоретическому минимуму. В некоторых специальных случаях удаётся избежать коллизий вообще. Например, если все ключи 
 * элементов известны заранее (или очень редко меняются), то для них можно найти некоторую совершенную хеш-функцию, которая 
 * распределит их по ячейкам хеш-таблицы без коллизий. Хеш-таблицы, использующие подобные хеш-функции, не нуждаются в 
 * механизме разрешения коллизий, и называются хеш-таблицами с прямой адресацией.
 * Число хранимых элементов деленное на размер массива называется коэффициентом заполнения хэш-таблицы. От этого параметра
 * зависит время выполнения операций.
 * 
 * Важное свойство хеш-таблиц состоит в том, что, при некоторых разумных допущениях, все три операции (поиск, вставка, 
 * удаление элементов) в среднем выполняются за время O(1). Но при этом не гарантируется, что время выполнения отдельной 
 * операции мало́. Это связано с тем, что при достижении некоторого значения коэффициента заполнения необходимо осуществлять 
 * перестройку индекса хеш-таблицы: увеличить значение размера массива H и заново добавить в пустую хеш-таблицу все пары.
 * 
 * Существуют несколько способов разрешения от коллизий. 1 метод - метод цепочек, 2 метод - открытой адресацией.
 * 
 * Метод открытой адресации:
 * В массиве H хранятся сами пары ключ-значение. Алгоритм вставки элемента проверяет ячейки массива H в некотором порядке до 
 * тех пор, пока не будет найдена первая свободная ячейка, в которую и будет записан новый элемент. Этот порядок вычисляется 
 * на лету, что позволяет сэкономить на памяти для указателей, требующихся в хеш-таблицах с цепочками.
 * Последовательность, в которой просматриваются ячейки хеш-таблицы, называется последовательностью проб. В общем случае, она 
 * зависит только от ключа элемента, то есть это последовательность h0(x), h1(x), …, hn — 1(x), где x — ключ элемента, а 
 * hi(x) — произвольные функции, сопоставляющие каждому ключу ячейку в хеш-таблице. Первый элемент в последовательности, 
 * как правило, равен значению некоторой хеш-функции от ключа, а остальные считаются от него одним из приведённых ниже 
 * способов. Для успешной работы алгоритмов поиска последовательность проб должна быть такой, чтобы все ячейки хеш-таблицы 
 * оказались просмотренными ровно по одному разу.
 * Алгоритм поиска просматривает ячейки хеш-таблицы в том же самом порядке, что и при вставке, до тех пор, пока не найдется 
 * либо элемент с искомым ключом, либо свободная ячейка (что означает отсутствие элемента в хеш-таблице).
 * Во всех операциях от ключа К берется хэш h. Во время выполнения операции put, если элемент массива t[h] null или deleted, 
 * то записываем в него пару (K,V). В противном случае переходи к элементу, находящемуся правее h (если такого элемента нет, 
 * то возвращаемся в начало массива) и проверяем его аналогичным образом. Алгоритм продолжается до тех пор, пока не найдется 
 * пустой или удаленный элемент или пока индекс снова не станет равным h. Во втором случае происходит переполнение хэш 
 * таблицы и запись новых значений в нее невозможен. Во время выполнения операции get также происходит циклическая проверка 
 * элементов массива, начиная с индекса h. Если элемент является парой и ключ этой пары совпадает с К, то возвращается 
 * значение V. Если же ключи не совпадают или элемент является deleted, то берется элемент, находящийся в массиве правее 
 * текущего (или первый элемент для последнего элемента в массиве). Если же элемент является null или же его индекс снова 
 * равен h, то выдается сообщение об отсутствии в ассоциативном массиве значений по данному ключу. Операция del сходна с 
 * операцией put за исключением того случая, что при нахождении ключа К мы значение данного элемента массива t заменяем на 
 * deleted.
 * У этого метода есть одни недостаток: при увеличении числа значений в массиве образуются длинные блоки из непустых 
 * элементов(кластеры), в результате чего увеличивается время работы основных операций ассоциативного массива. Более того 
 * блок длины а будет удлинятся с вероятностью (a+1)/m, т.е. чем длиннее будет становится кластер, тем больше вероятность что
 * он станет еще длиннее.
 * 
 * Последовательности проб
 * Ниже приведены некоторые распространенные типы последовательностей проб. Сразу оговорим, что нумерация элементов 
 * последовательности проб и ячеек хеш-таблицы ведётся от нуля, а N — размер хеш-таблицы (и, как замечено выше, также и 
 * длина последовательности проб).
 * Линейное пробирование: ячейки хеш-таблицы последовательно просматриваются с некоторым фиксированным интервалом k между 
 * ячейками (обычно, k = 1), то есть i-й элемент последовательности проб — это ячейка с номером (hash(x) + ik) mod N. Для 
 * того, чтобы все ячейки оказались просмотренными по одному разу, необходимо, чтобы k было взаимно-простым с размером 
 * хеш-таблицы.
 */


public class HashMapOpenAddress {

	public class DataItem {
		
		public int key;
		public String value;
		
		public DataItem(int key, String value) {
			
			this.key = key;
			this.value = value;
		}
		
		public int getKey() {
			
			return key;
		}
		
		public String getValue() {
			
			return value;
		}
	}
	
	private DataItem[] table;
	private int table_size;
	private DataItem nonItem;
	
	public HashMapOpenAddress(int size) {
		
		table_size = size;
		table = new DataItem[table_size];
		nonItem = new DataItem(-1, "");
	}
	
	public int hashCode(int key) {
		
		return key % table_size;
	}
	
	public String get(int key) {
		
		int hash = hashCode(key);
		
		while(table[hash] != null) {
			
			if(table[hash].getKey() == key) {
				
				return table[hash].getValue();
			}	
			
			++ hash;
			hash %= table_size;
		}
		
		return "-1";
	}
	
	public void add(int key, String value) {
		
		int hash = hashCode(key);
		
		while(table[hash] != null && table[hash].getKey() != -1) {
			
			++ hash;
			hash %= table_size;
		}
		
		table[hash] = new DataItem(key, value);
		
	}
	
	public void remove(int key) {
		
		int hash = hashCode(key);
		
		while(table[hash] != null) {
			
			if(table[hash].getKey() == key) {
				
				table[hash] = nonItem;
			}
			
			++ hash;
			hash %= table_size;
		}
	}
	
	public static void main(String[] args)	{
		
	
	}
}
